<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <title>3D Drawing App</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        body {
            font-family: Arial, sans-serif;
            overflow: hidden;
            background: white;
            color: black;
        }
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        #threeCanvas {
            width: 100%;
            height: 100%;
            display: block;
            touch-action: none;
        }
        
        #floatingPanel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: white;
            border: 2px solid black;
            width: min(280px, calc(100vw - 20px));
            box-shadow: 4px 4px 0 rgba(0,0,0,0.2);
            z-index: 1000;
            touch-action: auto;
        }
        #panelHeader {
            background: black;
            color: white;
            padding: 8px 12px;
            cursor: move;
            touch-action: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
            font-size: 14px;
        }
        #collapseBtn {
            background: white;
            color: black;
            border: 1px solid white;
            padding: 2px 8px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
        }
        #collapseBtn:hover {
            background: #ddd;
        }
        #panelContent {
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-height: 70vh;
            overflow-y: auto;
        }
        #panelContent.collapsed {
            display: none;
        }
        
        #drawCanvas {
            width: 100%;
            height: 200px;
            background: white;
            border: 2px solid black;
            cursor: crosshair;
            touch-action: auto;
        }
        #drawCanvas.eraser {
            cursor: cell;
        }
        #drawCanvas.line {
            cursor: crosshair;
        }
        #drawCanvas.circle {
            cursor: crosshair;
        }
        #drawCanvas.rectangle {
            cursor: crosshair;
        }
        #drawCanvas.fill {
            cursor: pointer;
        }
        
        button {
            padding: 8px;
            background: white;
            border: 2px solid black;
            color: black;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            touch-action: manipulation;
        }
        button:hover {
            background: #f0f0f0;
        }
        button:active {
            background: #ddd;
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            color: #666;
        }
        button.active {
            background: black;
            color: white;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
            padding: 8px;
            border: 1px solid black;
        }
        
        .control-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 4px;
        }
        
        .button-group-three {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 4px;
        }
        
        input[type="color"] {
            width: 40px;
            height: 24px;
            border: 2px solid black;
            cursor: pointer;
            padding: 0;
        }
        
        input[type="range"] {
            flex: 1;
        }
        
        input[type="checkbox"], input[type="radio"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }
        
        label {
            font-size: 11px;
            font-weight: bold;
        }
        
        .section-title {
            font-size: 12px;
            font-weight: bold;
            margin-top: 4px;
            padding: 4px 0;
            border-bottom: 2px solid black;
        }
        
        #objectList {
            min-height: 80px;
            max-height: 150px;
            overflow-y: auto;
            border: 2px solid black;
            background: white;
        }
        
        .objectItem {
            padding: 6px 8px;
            border-bottom: 1px solid #ccc;
            cursor: pointer;
            font-size: 11px;
            background: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .objectItem:hover {
            background: #f0f0f0;
        }
        .objectItem.selected {
            background: black;
            color: white;
            font-weight: bold;
        }
        .objectItem:last-child {
            border-bottom: none;
        }
        
        .objectName {
            flex: 1;
            cursor: pointer;
        }
        
        .objectActions {
            display: flex;
            gap: 4px;
        }
        
        .objectBtn {
            padding: 2px 6px;
            font-size: 10px;
            border: 1px solid currentColor;
        }
        
        .objectItem.selected .objectBtn {
            background: white;
            color: black;
            border-color: white;
        }
        
        .objectItem.selected .objectBtn:hover {
            background: #ddd;
        }
        
        .emptyList {
            padding: 12px;
            color: #666;
            font-size: 11px;
            text-align: center;
            font-style: italic;
        }
        
        .info-text {
            font-size: 10px;
            color: #666;
            line-height: 1.4;
        }
        
        .modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
        }
        
        .modal-content {
            background: white;
            border: 2px solid black;
            margin: 15% auto;
            padding: 20px;
            width: min(300px, calc(100vw - 40px));
            box-shadow: 4px 4px 0 rgba(0,0,0,0.3);
        }
        
        .modal-header {
            font-weight: bold;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 2px solid black;
        }
        
        .modal-body {
            margin-bottom: 12px;
        }
        
        .modal-footer {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
        }
        
        input[type="text"] {
            width: 100%;
            padding: 6px;
            border: 2px solid black;
            font-size: 12px;
        }
        
        select {
            width: 100%;
            padding: 6px;
            border: 2px solid black;
            font-size: 12px;
            background: white;
            cursor: pointer;
        }
        
        .radio-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-top: 8px;
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="threeCanvas"></canvas>
        
        <div id="floatingPanel">
            <div id="panelHeader">
                <span>3D DRAW TOOL</span>
                <button id="collapseBtn">−</button>
            </div>
            <div id="panelContent">
                <canvas id="drawCanvas"></canvas>
                
                <div class="button-group">
                    <button id="brushBtn" class="active">BRUSH</button>
                    <button id="eraserBtn">ERASER</button>
                </div>
                
                <div class="button-group">
                    <button id="lineBtn">LINE</button>
                    <button id="circleBtn">CIRCLE</button>
                </div>
                
                <div class="button-group">
                    <button id="rectangleBtn">RECTANGLE</button>
                    <button id="fillBtn">FILL</button>
                </div>
                
                <div class="control-group">
                    <div class="control-row">
                        <label>COLOR:</label>
                        <input type="color" id="colorPicker" value="#ff0000">
                    </div>
                    <div class="control-row">
                        <label>SIZE: <span id="brushValue">3</span>px</label>
                    </div>
                    <input type="range" id="brushSize" min="1" max="10" value="3">
                </div>
                
                <button id="clearBtn">CLEAR CANVAS</button>
                
                <div class="section-title">3D PROJECTION</div>
                <div class="control-group">
                    <label>
                        <input type="checkbox" id="volumeMode">
                        PROJECT AS VOLUME (3D)
                    </label>
                    <div class="radio-group" id="geometryGroup" style="display: none;">
                        <label>
                            <input type="radio" name="geometry" value="conversion" checked>
                            Conversion (Spheres)
                        </label>
                        <label>
                            <input type="radio" name="geometry" value="individual">
                            Individual (Icosahedrons)
                        </label>
                    </div>
                </div>
                
                <button id="projectBtn">PROJECT TO 3D</button>
                
                <div class="section-title">3D OBJECTS</div>
                <div id="objectList"></div>
                
                <div class="button-group" style="margin-top: 8px;">
                    <button id="exportObjBtn" disabled>EXPORT OBJ</button>
                    <button id="exportPlyBtn" disabled>EXPORT PLY</button>
                    <button id="loadToCanvasBtn" disabled>LOAD TO CANVAS</button>
                    <button id="duplicateBtn" disabled>DUPLICATE</button>
                    <button id="deleteBtn" disabled>DELETE</button>
                </div>
                
                <div class="section-title">CONTROLS</div>
                <div class="control-group">
                    <label>
                        <input type="checkbox" id="translateGizmo">
                        TRANSLATE GIZMO
                    </label>
                    <label>
                        <input type="checkbox" id="rotateGizmo">
                        ROTATE GIZMO
                    </label>
                    <label>
                        <input type="checkbox" id="scaleGizmo">
                        SCALE GIZMO
                    </label>
                </div>
                
                <div class="control-group">
                    <label>
                        <input type="checkbox" id="gridToggle" checked>
                        SHOW GRID
                    </label>
                </div>
                
                <div class="info-text">
                    <strong>DESKTOP:</strong><br>
                    • Middle-drag: orbit<br>
                    • Right-drag: pan<br>
                    • Scroll: zoom<br>
                    <strong>MOBILE:</strong><br>
                    • 1 finger: rotate<br>
                    • 2 fingers pinch: zoom<br>
                    • 2 fingers drag: pan
                </div>
            </div>
        </div>
    </div>

    <!-- Rename Modal -->
    <div id="renameModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">RENAME OBJECT</div>
            <div class="modal-body">
                <input type="text" id="renameInput" placeholder="Enter new name">
            </div>
            <div class="modal-footer">
                <button id="cancelRename">CANCEL</button>
                <button id="confirmRename">RENAME</button>
            </div>
        </div>
    </div>

    <!-- Export Modal -->
    <div id="exportModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">EXPORT OPTIONS</div>
            <div class="modal-body">
                <label>Select export type:</label>
                <div class="radio-group">
                    <label>
                        <input type="radio" name="exportType" value="conversion" checked>
                        Conversion (Spheres)
                    </label>
                    <label>
                        <input type="radio" name="exportType" value="individual">
                        Individual (Icosahedrons)
                    </label>
                </div>
            </div>
            <div class="modal-footer">
                <button id="cancelExport">CANCEL</button>
                <button id="confirmExport">EXPORT</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Drawing tool state
        let currentTool = 'brush';
        
        // 2D Drawing Canvas
        const drawCanvas = document.getElementById('drawCanvas');
        const ctx = drawCanvas.getContext('2d');
        drawCanvas.width = 256;
        drawCanvas.height = 200;
        
        let isDrawing = false;
        let currentColor = '#ff0000';
        let brushSize = 3;
        let lineStartX, lineStartY;
        let circleStartX, circleStartY;
        let rectStartX, rectStartY;
        let tempCanvas = document.createElement('canvas');
        let tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = drawCanvas.width;
        tempCanvas.height = drawCanvas.height;
        
        // Tool selection
        function setTool(tool) {
            currentTool = tool;
            document.getElementById('brushBtn').classList.remove('active');
            document.getElementById('eraserBtn').classList.remove('active');
            document.getElementById('lineBtn').classList.remove('active');
            document.getElementById('circleBtn').classList.remove('active');
            document.getElementById('rectangleBtn').classList.remove('active');
            document.getElementById('fillBtn').classList.remove('active');
            
            drawCanvas.classList.remove('eraser', 'line', 'circle', 'rectangle', 'fill');
            
            if (tool === 'brush') {
                document.getElementById('brushBtn').classList.add('active');
            } else if (tool === 'eraser') {
                document.getElementById('eraserBtn').classList.add('active');
                drawCanvas.classList.add('eraser');
            } else if (tool === 'line') {
                document.getElementById('lineBtn').classList.add('active');
                drawCanvas.classList.add('line');
            } else if (tool === 'circle') {
                document.getElementById('circleBtn').classList.add('active');
                drawCanvas.classList.add('circle');
            } else if (tool === 'rectangle') {
                document.getElementById('rectangleBtn').classList.add('active');
                drawCanvas.classList.add('rectangle');
            } else if (tool === 'fill') {
                document.getElementById('fillBtn').classList.add('active');
                drawCanvas.classList.add('fill');
            }
        }
        
        document.getElementById('brushBtn').addEventListener('click', () => setTool('brush'));
        document.getElementById('eraserBtn').addEventListener('click', () => setTool('eraser'));
        document.getElementById('lineBtn').addEventListener('click', () => setTool('line'));
        document.getElementById('circleBtn').addEventListener('click', () => setTool('circle'));
        document.getElementById('rectangleBtn').addEventListener('click', () => setTool('rectangle'));
        document.getElementById('fillBtn').addEventListener('click', () => setTool('fill'));
        
        document.getElementById('colorPicker').addEventListener('input', (e) => {
            currentColor = e.target.value;
        });
        
        document.getElementById('brushSize').addEventListener('input', (e) => {
            brushSize = parseInt(e.target.value);
            document.getElementById('brushValue').textContent = brushSize;
        });
        
        function getCanvasCoords(e, canvas) {
            const rect = canvas.getBoundingClientRect();
            let clientX, clientY;
            
            if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }
            
            const x = (clientX - rect.left) * (canvas.width / rect.width);
            const y = (clientY - rect.top) * (canvas.height / rect.height);
            return { x, y };
        }
        
        function floodFill(x, y, fillColor) {
            const imageData = ctx.getImageData(0, 0, drawCanvas.width, drawCanvas.height);
            const pixels = imageData.data;
            const startPos = (Math.floor(y) * drawCanvas.width + Math.floor(x)) * 4;
            
            const startR = pixels[startPos];
            const startG = pixels[startPos + 1];
            const startB = pixels[startPos + 2];
            const startA = pixels[startPos + 3];
            
            const fillR = parseInt(fillColor.substring(1, 3), 16);
            const fillG = parseInt(fillColor.substring(3, 5), 16);
            const fillB = parseInt(fillColor.substring(5, 7), 16);
            
            if (startR === fillR && startG === fillG && startB === fillB) {
                return;
            }
            
            const stack = [[Math.floor(x), Math.floor(y)]];
            
            while (stack.length > 0) {
                const [px, py] = stack.pop();
                
                if (px < 0 || px >= drawCanvas.width || py < 0 || py >= drawCanvas.height) continue;
                
                const pos = (py * drawCanvas.width + px) * 4;
                
                if (pixels[pos] === startR && pixels[pos + 1] === startG && 
                    pixels[pos + 2] === startB && pixels[pos + 3] === startA) {
                    
                    pixels[pos] = fillR;
                    pixels[pos + 1] = fillG;
                    pixels[pos + 2] = fillB;
                    pixels[pos + 3] = 255;
                    
                    stack.push([px + 1, py]);
                    stack.push([px - 1, py]);
                    stack.push([px, py + 1]);
                    stack.push([px, py - 1]);
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
        }
        
        function startDrawing(e) {
            e.preventDefault();
            const coords = getCanvasCoords(e, drawCanvas);
            
            if (currentTool === 'fill') {
                floodFill(coords.x, coords.y, currentColor);
                return;
            }
            
            isDrawing = true;
            
            if (currentTool === 'brush' || currentTool === 'eraser') {
                ctx.beginPath();
                ctx.moveTo(coords.x, coords.y);
                
                if (currentTool === 'eraser') {
                    ctx.globalCompositeOperation = 'destination-out';
                } else {
                    ctx.globalCompositeOperation = 'source-over';
                }
            } else if (currentTool === 'line') {
                lineStartX = coords.x;
                lineStartY = coords.y;
                tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
                tempCtx.drawImage(drawCanvas, 0, 0);
            } else if (currentTool === 'circle') {
                circleStartX = coords.x;
                circleStartY = coords.y;
                tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
                tempCtx.drawImage(drawCanvas, 0, 0);
            } else if (currentTool === 'rectangle') {
                rectStartX = coords.x;
                rectStartY = coords.y;
                tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
                tempCtx.drawImage(drawCanvas, 0, 0);
            }
        }
        
        function draw(e) {
            if (!isDrawing) return;
            e.preventDefault();
            
            const coords = getCanvasCoords(e, drawCanvas);
            
            if (currentTool === 'brush' || currentTool === 'eraser') {
                ctx.lineTo(coords.x, coords.y);
                ctx.strokeStyle = currentTool === 'eraser' ? 'rgba(0,0,0,1)' : currentColor;
                ctx.lineWidth = brushSize;
                ctx.lineCap = 'round';
                ctx.stroke();
            } else if (currentTool === 'line') {
                ctx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
                ctx.drawImage(tempCanvas, 0, 0);
                
                ctx.beginPath();
                ctx.moveTo(lineStartX, lineStartY);
                ctx.lineTo(coords.x, coords.y);
                ctx.strokeStyle = currentColor;
                ctx.lineWidth = brushSize;
                ctx.lineCap = 'round';
                ctx.stroke();
            } else if (currentTool === 'circle') {
                const radius = Math.sqrt(
                    Math.pow(coords.x - circleStartX, 2) + 
                    Math.pow(coords.y - circleStartY, 2)
                );
                
                ctx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
                ctx.drawImage(tempCanvas, 0, 0);
                
                ctx.beginPath();
                ctx.arc(circleStartX, circleStartY, radius, 0, Math.PI * 2);
                ctx.strokeStyle = currentColor;
                ctx.lineWidth = brushSize;
                ctx.stroke();
            } else if (currentTool === 'rectangle') {
                ctx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
                ctx.drawImage(tempCanvas, 0, 0);
                
                const width = coords.x - rectStartX;
                const height = coords.y - rectStartY;
                
                ctx.beginPath();
                ctx.rect(rectStartX, rectStartY, width, height);
                ctx.strokeStyle = currentColor;
                ctx.lineWidth = brushSize;
                ctx.stroke();
            }
        }
        
        function stopDrawing(e) {
            if (!isDrawing) return;
            isDrawing = false;
            ctx.globalCompositeOperation = 'source-over';
        }
        
        // Mouse events
        drawCanvas.addEventListener('mousedown', startDrawing);
        drawCanvas.addEventListener('mousemove', draw);
        drawCanvas.addEventListener('mouseup', stopDrawing);
        drawCanvas.addEventListener('mouseleave', stopDrawing);
        
        // Touch events for drawing canvas
        drawCanvas.addEventListener('touchstart', startDrawing, { passive: false });
        drawCanvas.addEventListener('touchmove', draw, { passive: false });
        drawCanvas.addEventListener('touchend', stopDrawing, { passive: false });
        drawCanvas.addEventListener('touchcancel', stopDrawing, { passive: false });
        
        document.getElementById('clearBtn').addEventListener('click', () => {
            ctx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
        });
        
        // Volume mode geometry selection
        document.getElementById('volumeMode').addEventListener('change', (e) => {
            document.getElementById('geometryGroup').style.display = e.target.checked ? 'block' : 'none';
        });
        
        // Floating panel drag
        const panel = document.getElementById('floatingPanel');
        const header = document.getElementById('panelHeader');
        let isDraggingPanel = false;
        let panelOffset = { x: 0, y: 0 };
        
        function startPanelDrag(e) {
            if (e.target === document.getElementById('collapseBtn')) return;
            isDraggingPanel = true;
            
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            
            panelOffset.x = clientX - panel.offsetLeft;
            panelOffset.y = clientY - panel.offsetTop;
        }
        
        function doPanelDrag(e) {
            if (!isDraggingPanel) return;
            
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            
            panel.style.left = (clientX - panelOffset.x) + 'px';
            panel.style.top = (clientY - panelOffset.y) + 'px';
        }
        
        function stopPanelDrag() {
            isDraggingPanel = false;
        }
        
        header.addEventListener('mousedown', startPanelDrag);
        header.addEventListener('touchstart', startPanelDrag, { passive: true });
        
        document.addEventListener('mousemove', doPanelDrag);
        document.addEventListener('touchmove', doPanelDrag, { passive: true });
        
        document.addEventListener('mouseup', stopPanelDrag);
        document.addEventListener('touchend', stopPanelDrag);
        
        document.getElementById('collapseBtn').addEventListener('click', () => {
            const content = document.getElementById('panelContent');
            const btn = document.getElementById('collapseBtn');
            content.classList.toggle('collapsed');
            btn.textContent = content.classList.contains('collapsed') ? '+' : '−';
        });
        
        // Three.js Scene
        const threeCanvas = document.getElementById('threeCanvas');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(5, 5, 5);
        camera.lookAt(0, 0, 0);
        
        // OPTIMIZATION: Use lower pixel ratio on low-end devices
        const pixelRatio = Math.min(window.devicePixelRatio, 2);
        const renderer = new THREE.WebGLRenderer({ 
            canvas: threeCanvas, 
            antialias: pixelRatio <= 1,
            powerPreference: "high-performance"
        });
        renderer.setPixelRatio(pixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        
        // Lighting - optimized for performance
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.3);
        directionalLight.position.set(5, 5, 5);
        scene.add(directionalLight);
        
        // Grid
        const gridHelper = new THREE.GridHelper(10, 10, 0x000000, 0x666666);
        scene.add(gridHelper);
        
        document.getElementById('gridToggle').addEventListener('change', (e) => {
            gridHelper.visible = e.target.checked;
            requestRenderIfNeeded();
        });
        
        // Objects
        let objects = [];
        let selectedObject = null;
        let objectCounter = 0;
        
        // Camera controls
        let cameraDistance = Math.sqrt(camera.position.x ** 2 + camera.position.y ** 2 + camera.position.z ** 2);
        let theta = Math.atan2(camera.position.x, camera.position.z);
        let phi = Math.acos(camera.position.y / cameraDistance);
        const lookAtTarget = new THREE.Vector3(0, 0, 0);
        
        function updateCameraPosition() {
            camera.position.x = lookAtTarget.x + cameraDistance * Math.sin(phi) * Math.sin(theta);
            camera.position.y = lookAtTarget.y + cameraDistance * Math.cos(phi);
            camera.position.z = lookAtTarget.z + cameraDistance * Math.sin(phi) * Math.cos(theta);
            camera.lookAt(lookAtTarget);
            requestRenderIfNeeded();
        }
        
        // Gizmos
        const gizmos = {
            translate: null,
            rotate: null,
            scale: null
        };
        
        function createTranslateGizmo() {
            const group = new THREE.Group();
            const arrowLength = 1.5;
            const arrowHeadLength = 0.3;
            const arrowHeadWidth = 0.15;
            
            // X axis (red)
            const xGeo = new THREE.CylinderGeometry(0.03, 0.03, arrowLength, 8);
            const xMat = new THREE.MeshBasicMaterial({ 
                color: 0xff0000,
                depthTest: false,
                depthWrite: false
            });
            const xArrow = new THREE.Mesh(xGeo, xMat);
            xArrow.rotation.z = -Math.PI / 2;
            xArrow.position.x = arrowLength / 2;
            xArrow.userData.axis = 'x';
            xArrow.userData.gizmoType = 'translate';
            xArrow.renderOrder = 999;
            
            const xHeadGeo = new THREE.ConeGeometry(arrowHeadWidth, arrowHeadLength, 8);
            const xHead = new THREE.Mesh(xHeadGeo, xMat);
            xHead.rotation.z = -Math.PI / 2;
            xHead.position.x = arrowLength;
            xHead.userData.axis = 'x';
            xHead.userData.gizmoType = 'translate';
            xHead.renderOrder = 999;
            
            group.add(xArrow);
            group.add(xHead);
            
            // Y axis (green)
            const yGeo = new THREE.CylinderGeometry(0.03, 0.03, arrowLength, 8);
            const yMat = new THREE.MeshBasicMaterial({ 
                color: 0x00ff00,
                depthTest: false,
                depthWrite: false
            });
            const yArrow = new THREE.Mesh(yGeo, yMat);
            yArrow.position.y = arrowLength / 2;
            yArrow.userData.axis = 'y';
            yArrow.userData.gizmoType = 'translate';
            yArrow.renderOrder = 999;
            
            const yHeadGeo = new THREE.ConeGeometry(arrowHeadWidth, arrowHeadLength, 8);
            const yHead = new THREE.Mesh(yHeadGeo, yMat);
            yHead.position.y = arrowLength;
            yHead.userData.axis = 'y';
            yHead.userData.gizmoType = 'translate';
            yHead.renderOrder = 999;
            
            group.add(yArrow);
            group.add(yHead);
            
            // Z axis (blue)
            const zGeo = new THREE.CylinderGeometry(0.03, 0.03, arrowLength, 8);
            const zMat = new THREE.MeshBasicMaterial({ 
                color: 0x0000ff,
                depthTest: false,
                depthWrite: false
            });
            const zArrow = new THREE.Mesh(zGeo, zMat);
            zArrow.rotation.x = Math.PI / 2;
            zArrow.position.z = arrowLength / 2;
            zArrow.userData.axis = 'z';
            zArrow.userData.gizmoType = 'translate';
            zArrow.renderOrder = 999;
            
            const zHeadGeo = new THREE.ConeGeometry(arrowHeadWidth, arrowHeadLength, 8);
            const zHead = new THREE.Mesh(zHeadGeo, zMat);
            zHead.rotation.x = Math.PI / 2;
            zHead.position.z = arrowLength;
            zHead.userData.axis = 'z';
            zHead.userData.gizmoType = 'translate';
            zHead.renderOrder = 999;
            
            group.add(zArrow);
            group.add(zHead);
            
            group.visible = false;
            return group;
        }
        
        function createRotateGizmo() {
            const group = new THREE.Group();
            const radius = 1.5;
            const segments = 64;
            
            // X axis (red)
            const xGeo = new THREE.TorusGeometry(radius, 0.03, 16, segments);
            const xMat = new THREE.MeshBasicMaterial({ 
                color: 0xff0000,
                depthTest: false,
                depthWrite: false
            });
            const xTorus = new THREE.Mesh(xGeo, xMat);
            xTorus.rotation.y = Math.PI / 2;
            xTorus.userData.axis = 'x';
            xTorus.userData.gizmoType = 'rotate';
            xTorus.renderOrder = 999;
            group.add(xTorus);
            
            // Y axis (green)
            const yGeo = new THREE.TorusGeometry(radius, 0.03, 16, segments);
            const yMat = new THREE.MeshBasicMaterial({ 
                color: 0x00ff00,
                depthTest: false,
                depthWrite: false
            });
            const yTorus = new THREE.Mesh(yGeo, yMat);
            yTorus.rotation.x = Math.PI / 2;
            yTorus.userData.axis = 'y';
            yTorus.userData.gizmoType = 'rotate';
            yTorus.renderOrder = 999;
            group.add(yTorus);
            
            // Z axis (blue)
            const zGeo = new THREE.TorusGeometry(radius, 0.03, 16, segments);
            const zMat = new THREE.MeshBasicMaterial({ 
                color: 0x0000ff,
                depthTest: false,
                depthWrite: false
            });
            const zTorus = new THREE.Mesh(zGeo, zMat);
            zTorus.userData.axis = 'z';
            zTorus.userData.gizmoType = 'rotate';
            zTorus.renderOrder = 999;
            group.add(zTorus);
            
            group.visible = false;
            return group;
        }
        
        function createScaleGizmo() {
            const group = new THREE.Group();
            const arrowLength = 1.5;
            const cubeSize = 0.15;
            
            // X axis (red)
            const xGeo = new THREE.CylinderGeometry(0.03, 0.03, arrowLength, 8);
            const xMat = new THREE.MeshBasicMaterial({ 
                color: 0xff0000,
                depthTest: false,
                depthWrite: false
            });
            const xArrow = new THREE.Mesh(xGeo, xMat);
            xArrow.rotation.z = -Math.PI / 2;
            xArrow.position.x = arrowLength / 2;
            xArrow.userData.axis = 'x';
            xArrow.userData.gizmoType = 'scale';
            xArrow.renderOrder = 999;
            
            const xCubeGeo = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
            const xCube = new THREE.Mesh(xCubeGeo, xMat);
            xCube.position.x = arrowLength;
            xCube.userData.axis = 'x';
            xCube.userData.gizmoType = 'scale';
            xCube.renderOrder = 999;
            
            group.add(xArrow);
            group.add(xCube);
            
            // Y axis (green)
            const yGeo = new THREE.CylinderGeometry(0.03, 0.03, arrowLength, 8);
            const yMat = new THREE.MeshBasicMaterial({ 
                color: 0x00ff00,
                depthTest: false,
                depthWrite: false
            });
            const yArrow = new THREE.Mesh(yGeo, yMat);
            yArrow.position.y = arrowLength / 2;
            yArrow.userData.axis = 'y';
            yArrow.userData.gizmoType = 'scale';
            yArrow.renderOrder = 999;
            
            const yCubeGeo = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
            const yCube = new THREE.Mesh(yCubeGeo, yMat);
            yCube.position.y = arrowLength;
            yCube.userData.axis = 'y';
            yCube.userData.gizmoType = 'scale';
            yCube.renderOrder = 999;
            
            group.add(yArrow);
            group.add(yCube);
            
            // Z axis (blue)
            const zGeo = new THREE.CylinderGeometry(0.03, 0.03, arrowLength, 8);
            const zMat = new THREE.MeshBasicMaterial({ 
                color: 0x0000ff,
                depthTest: false,
                depthWrite: false
            });
            const zArrow = new THREE.Mesh(zGeo, zMat);
            zArrow.rotation.x = Math.PI / 2;
            zArrow.position.z = arrowLength / 2;
            zArrow.userData.axis = 'z';
            zArrow.userData.gizmoType = 'scale';
            zArrow.renderOrder = 999;
            
            const zCubeGeo = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
            const zCube = new THREE.Mesh(zCubeGeo, zMat);
            zCube.position.z = arrowLength;
            zCube.userData.axis = 'z';
            zCube.userData.gizmoType = 'scale';
            zCube.renderOrder = 999;
            
            group.add(zArrow);
            group.add(zCube);
            
            group.visible = false;
            return group;
        }
        
        gizmos.translate = createTranslateGizmo();
        gizmos.rotate = createRotateGizmo();
        gizmos.scale = createScaleGizmo();
        
        scene.add(gizmos.translate);
        scene.add(gizmos.rotate);
        scene.add(gizmos.scale);
        
        // Gizmo checkboxes
        document.getElementById('translateGizmo').addEventListener('change', (e) => {
            if (e.target.checked) {
                document.getElementById('rotateGizmo').checked = false;
                document.getElementById('scaleGizmo').checked = false;
            }
            updateGizmoVisibility();
        });
        
        document.getElementById('rotateGizmo').addEventListener('change', (e) => {
            if (e.target.checked) {
                document.getElementById('translateGizmo').checked = false;
                document.getElementById('scaleGizmo').checked = false;
            }
            updateGizmoVisibility();
        });
        
        document.getElementById('scaleGizmo').addEventListener('change', (e) => {
            if (e.target.checked) {
                document.getElementById('translateGizmo').checked = false;
                document.getElementById('rotateGizmo').checked = false;
            }
            updateGizmoVisibility();
        });
        
        function updateGizmoVisibility() {
            gizmos.translate.visible = document.getElementById('translateGizmo').checked && selectedObject !== null;
            gizmos.rotate.visible = document.getElementById('rotateGizmo').checked && selectedObject !== null;
            gizmos.scale.visible = document.getElementById('scaleGizmo').checked && selectedObject !== null;
            
            if (selectedObject) {
                gizmos.translate.position.copy(selectedObject.position);
                gizmos.rotate.position.copy(selectedObject.position);
                gizmos.scale.position.copy(selectedObject.position);
            }
            requestRenderIfNeeded();
        }
        
        // Shared geometry cache for optimization
        const geometryCache = {
            sphere: new THREE.SphereGeometry(0.08, 8, 8),
            icosahedron: new THREE.IcosahedronGeometry(0.08, 1)
        };
        
        // OPTIMIZATION: Render on demand instead of continuous animation
        let needsRender = true;
        function requestRenderIfNeeded() {
            needsRender = true;
        }
        
        // Create volumetric mesh from drawing (optimized with merged geometry)
        function createVolumetricMesh(imageData, color, geometryType) {
            const spheres = [];
            const sampleStep = 2;
            
            for (let y = 0; y < drawCanvas.height; y += sampleStep) {
                for (let x = 0; x < drawCanvas.width; x += sampleStep) {
                    const idx = (y * drawCanvas.width + x) * 4;
                    const alpha = imageData.data[idx + 3];
                    
                    if (alpha > 128) {
                        const r = imageData.data[idx];
                        const g = imageData.data[idx + 1];
                        const b = imageData.data[idx + 2];
                        
                        const nx = (x / drawCanvas.width) * 2 - 1;
                        const ny = -(y / drawCanvas.height) * 2 + 1;
                        
                        spheres.push({
                            x: nx * 2,
                            y: ny * 2,
                            z: 0,
                            r: r / 255,
                            g: g / 255,
                            b: b / 255
                        });
                    }
                }
            }
            
            if (spheres.length === 0) return null;
            
            // OPTIMIZATION: Use merged geometry for better performance
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const colors = [];
            
            const baseGeo = geometryType === 'individual' ? geometryCache.icosahedron : geometryCache.sphere;
            const spherePositions = baseGeo.attributes.position.array;
            
            spheres.forEach(sphere => {
                for (let i = 0; i < spherePositions.length; i += 3) {
                    vertices.push(
                        spherePositions[i] + sphere.x,
                        spherePositions[i + 1] + sphere.y,
                        spherePositions[i + 2] + sphere.z
                    );
                    colors.push(sphere.r, sphere.g, sphere.b);
                }
            });
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.computeVertexNormals();
            
            const material = new THREE.MeshLambertMaterial({
                vertexColors: true,
                side: THREE.DoubleSide
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            mesh.userData.sphereData = spheres;
            mesh.userData.geometryType = geometryType;
            return mesh;
        }
        
        // Project to 3D
        document.getElementById('projectBtn').addEventListener('click', () => {
            const volumeMode = document.getElementById('volumeMode').checked;
            const imageData = ctx.getImageData(0, 0, drawCanvas.width, drawCanvas.height);
            
            let mesh;
            
            if (volumeMode) {
                const geometryType = document.querySelector('input[name="geometry"]:checked').value;
                mesh = createVolumetricMesh(imageData, currentColor, geometryType);
                if (!mesh) {
                    alert('No drawing detected! Draw something first.');
                    return;
                }
            } else {
                const texture = new THREE.CanvasTexture(drawCanvas);
                texture.needsUpdate = true;
                
                const geometry = new THREE.PlaneGeometry(2, 2);
                const material = new THREE.MeshBasicMaterial({ 
                    map: texture, 
                    side: THREE.DoubleSide,
                    transparent: true,
                    alphaTest: 0.1
                });
                mesh = new THREE.Mesh(geometry, material);
                mesh.userData.canvasData = imageData;
            }
            
            mesh.position.z = objects.length * -0.5;
            mesh.userData.id = ++objectCounter;
            mesh.userData.name = `${volumeMode ? 'Volume' : 'Drawing'} ${objectCounter}`;
            mesh.userData.isVolume = volumeMode;
            
            scene.add(mesh);
            objects.push(mesh);
            
            updateObjectList();
            selectObject(mesh);
            requestRenderIfNeeded();
        });
        
        function updateObjectList() {
            const list = document.getElementById('objectList');
            list.innerHTML = '';
            if (objects.length === 0) {
                list.innerHTML = '<div class="emptyList">No objects yet</div>';
                return;
            }
            objects.forEach(obj => {
                const item = document.createElement('div');
                item.className = 'objectItem';
                if (selectedObject === obj) item.classList.add('selected');
                
                const nameSpan = document.createElement('span');
                nameSpan.className = 'objectName';
                nameSpan.textContent = obj.userData.name;
                nameSpan.addEventListener('click', () => selectObject(obj));
                
                const actions = document.createElement('div');
                actions.className = 'objectActions';
                
                const renameBtn = document.createElement('button');
                renameBtn.className = 'objectBtn';
                renameBtn.textContent = 'R';
                renameBtn.title = 'Rename';
                renameBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    showRenameModal(obj);
                });
                
                actions.appendChild(renameBtn);
                item.appendChild(nameSpan);
                item.appendChild(actions);
                list.appendChild(item);
            });
        }
        
        function selectObject(obj) {
            selectedObject = obj;
            updateObjectList();
            updateGizmoVisibility();
            document.getElementById('deleteBtn').disabled = false;
            document.getElementById('exportObjBtn').disabled = false;
            document.getElementById('exportPlyBtn').disabled = false;
            document.getElementById('loadToCanvasBtn').disabled = false;
            document.getElementById('duplicateBtn').disabled = false;
        }
        
        function deselectObject() {
            selectedObject = null;
            updateObjectList();
            updateGizmoVisibility();
            document.getElementById('deleteBtn').disabled = true;
            document.getElementById('exportObjBtn').disabled = true;
            document.getElementById('exportPlyBtn').disabled = true;
            document.getElementById('loadToCanvasBtn').disabled = true;
            document.getElementById('duplicateBtn').disabled = true;
        }
        
        document.getElementById('deleteBtn').addEventListener('click', () => {
            if (selectedObject) {
                scene.remove(selectedObject);
                if (selectedObject.geometry) selectedObject.geometry.dispose();
                if (selectedObject.material) {
                    if (selectedObject.material.map) selectedObject.material.map.dispose();
                    selectedObject.material.dispose();
                }
                objects = objects.filter(obj => obj !== selectedObject);
                deselectObject();
                updateObjectList();
                requestRenderIfNeeded();
            }
        });
        
        // Duplicate object
        document.getElementById('duplicateBtn').addEventListener('click', () => {
            if (!selectedObject) return;
            
            const original = selectedObject;
            let mesh;
            
            if (original.userData.isVolume && original.userData.sphereData) {
                // Clone volumetric mesh
                const geometry = original.geometry.clone();
                const material = original.material.clone();
                mesh = new THREE.Mesh(geometry, material);
                mesh.userData.sphereData = [...original.userData.sphereData];
                mesh.userData.geometryType = original.userData.geometryType;
                mesh.userData.isVolume = true;
            } else {
                // Clone plane mesh
                const geometry = original.geometry.clone();
                const material = original.material.clone();
                if (original.material.map) {
                    material.map = original.material.map.clone();
                    material.map.needsUpdate = true;
                }
                mesh = new THREE.Mesh(geometry, material);
                mesh.userData.canvasData = original.userData.canvasData;
                mesh.userData.isVolume = false;
            }
            
            // Copy transformation
            mesh.position.copy(original.position);
            mesh.position.x += 0.5;
            mesh.rotation.copy(original.rotation);
            mesh.scale.copy(original.scale);
            
            mesh.userData.id = ++objectCounter;
            mesh.userData.name = `${original.userData.name}-copy`;
            
            scene.add(mesh);
            objects.push(mesh);
            
            updateObjectList();
            selectObject(mesh);
            requestRenderIfNeeded();
        });
        
        // Rename modal
        let objectToRename = null;
        
        function showRenameModal(obj) {
            objectToRename = obj;
            document.getElementById('renameInput').value = obj.userData.name;
            document.getElementById('renameModal').style.display = 'block';
            document.getElementById('renameInput').focus();
            document.getElementById('renameInput').select();
        }
        
        document.getElementById('cancelRename').addEventListener('click', () => {
            document.getElementById('renameModal').style.display = 'none';
            objectToRename = null;
        });
        
        document.getElementById('confirmRename').addEventListener('click', () => {
            if (objectToRename) {
                const newName = document.getElementById('renameInput').value.trim();
                if (newName) {
                    objectToRename.userData.name = newName;
                    updateObjectList();
                }
                document.getElementById('renameModal').style.display = 'none';
                objectToRename = null;
            }
        });
        
        document.getElementById('renameInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                document.getElementById('confirmRename').click();
            }
        });
        
        // Load to canvas
        document.getElementById('loadToCanvasBtn').addEventListener('click', () => {
            if (!selectedObject) return;
            
            ctx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
            
            if (selectedObject.userData.canvasData) {
                ctx.putImageData(selectedObject.userData.canvasData, 0, 0);
            } else if (selectedObject.userData.isVolume && selectedObject.userData.sphereData) {
                // Reconstruct drawing from sphere data
                const spheres = selectedObject.userData.sphereData;
                spheres.forEach(sphere => {
                    const x = ((sphere.x / 2 + 1) / 2) * drawCanvas.width;
                    const y = ((1 - sphere.y / 2) / 2) * drawCanvas.height;
                    const color = `rgb(${Math.floor(sphere.r * 255)}, ${Math.floor(sphere.g * 255)}, ${Math.floor(sphere.b * 255)})`;
                    
                    ctx.fillStyle = color;
                    ctx.fillRect(x - 1, y - 1, 3, 3);
                });
            } else if (selectedObject.material && selectedObject.material.map) {
                const img = selectedObject.material.map.image;
                if (img) {
                    ctx.drawImage(img, 0, 0, drawCanvas.width, drawCanvas.height);
                }
            }
        });
        
        // Export functions
        let exportFormat = '';
        
        document.getElementById('exportObjBtn').addEventListener('click', () => {
            if (!selectedObject) return;
            exportFormat = 'obj';
            if (selectedObject.userData.isVolume) {
                showExportModal();
            } else {
                exportGeometry('conversion');
            }
        });
        
        document.getElementById('exportPlyBtn').addEventListener('click', () => {
            if (!selectedObject) return;
            exportFormat = 'ply';
            if (selectedObject.userData.isVolume) {
                showExportModal();
            } else {
                exportGeometry('conversion');
            }
        });
        
        function showExportModal() {
            document.getElementById('exportModal').style.display = 'block';
        }
        
        document.getElementById('cancelExport').addEventListener('click', () => {
            document.getElementById('exportModal').style.display = 'none';
        });
        
        document.getElementById('confirmExport').addEventListener('click', () => {
            const exportType = document.querySelector('input[name="exportType"]:checked').value;
            document.getElementById('exportModal').style.display = 'none';
            exportGeometry(exportType);
        });
        
        function exportGeometry(geometryType) {
            if (!selectedObject) return;
            
            let geometry;
            
            if (selectedObject.userData.isVolume && selectedObject.userData.sphereData) {
                const spheres = selectedObject.userData.sphereData;
                geometry = new THREE.BufferGeometry();
                const vertices = [];
                const colors = [];
                
                const baseGeo = geometryType === 'individual' ? geometryCache.icosahedron : geometryCache.sphere;
                const spherePositions = baseGeo.attributes.position.array;
                
                spheres.forEach(sphere => {
                    for (let i = 0; i < spherePositions.length; i += 3) {
                        vertices.push(
                            spherePositions[i] + sphere.x,
                            spherePositions[i + 1] + sphere.y,
                            spherePositions[i + 2] + sphere.z
                        );
                        colors.push(sphere.r, sphere.g, sphere.b);
                    }
                });
                
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                geometry.computeVertexNormals();
            } else {
                geometry = selectedObject.geometry;
            }
            
            if (exportFormat === 'obj') {
                exportOBJ(geometry, selectedObject.userData.name);
            } else if (exportFormat === 'ply') {
                exportPLY(geometry, selectedObject.userData.name);
            }
        }
        
        function exportOBJ(geometry, filename) {
            const positions = geometry.attributes.position.array;
            const colors = geometry.attributes.color ? geometry.attributes.color.array : null;
            
            let objContent = '# Exported from 3D Drawing App\n';
            objContent += `o ${filename}\n`;
            
            for (let i = 0; i < positions.length; i += 3) {
                const r = colors ? colors[i] : 1;
                const g = colors ? colors[i + 1] : 1;
                const b = colors ? colors[i + 2] : 1;
                objContent += `v ${positions[i]} ${positions[i + 1]} ${positions[i + 2]} ${r} ${g} ${b}\n`;
            }
            
            const numVertices = positions.length / 3;
            for (let i = 0; i < numVertices; i += 3) {
                objContent += `f ${i + 1} ${i + 2} ${i + 3}\n`;
            }
            
            downloadFile(objContent, `${filename}.obj`, 'text/plain');
        }
        
        function exportPLY(geometry, filename) {
            const positions = geometry.attributes.position.array;
            const colors = geometry.attributes.color ? geometry.attributes.color.array : null;
            const numVertices = positions.length / 3;
            const numFaces = numVertices / 3;
            
            let plyContent = 'ply\n';
            plyContent += 'format ascii 1.0\n';
            plyContent += `element vertex ${numVertices}\n`;
            plyContent += 'property float x\n';
            plyContent += 'property float y\n';
            plyContent += 'property float z\n';
            if (colors) {
                plyContent += 'property uchar red\n';
                plyContent += 'property uchar green\n';
                plyContent += 'property uchar blue\n';
            }
            plyContent += `element face ${numFaces}\n`;
            plyContent += 'property list uchar int vertex_indices\n';
            plyContent += 'end_header\n';
            
            for (let i = 0; i < positions.length; i += 3) {
                plyContent += `${positions[i]} ${positions[i + 1]} ${positions[i + 2]}`;
                if (colors) {
                    const r = Math.floor(colors[i] * 255);
                    const g = Math.floor(colors[i + 1] * 255);
                    const b = Math.floor(colors[i + 2] * 255);
                    plyContent += ` ${r} ${g} ${b}`;
                }
                plyContent += '\n';
            }
            
            for (let i = 0; i < numVertices; i += 3) {
                plyContent += `3 ${i} ${i + 1} ${i + 2}\n`;
            }
            
            downloadFile(plyContent, `${filename}.ply`, 'text/plain');
        }
        
        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }
        
        // TOUCH CONTROLS FOR 3D CANVAS
        let touches = [];
        let lastPinchDistance = 0;
        let lastTouchCenter = { x: 0, y: 0 };
        let isPinching = false;
        
        function getTouchDistance(touch1, touch2) {
            const dx = touch2.clientX - touch1.clientX;
            const dy = touch2.clientY - touch1.clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }
        
        function getTouchCenter(touch1, touch2) {
            return {
                x: (touch1.clientX + touch2.clientX) / 2,
                y: (touch1.clientY + touch2.clientY) / 2
            };
        }
        
        // Mouse/Touch interaction
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let isDraggingGizmo = false;
        let activeGizmo = null;
        let activeAxis = null;
        let dragPlane = new THREE.Plane();
        let dragStart = new THREE.Vector3();
        let dragCurrent = new THREE.Vector3();
        let objectStartPosition = new THREE.Vector3();
        let objectStartRotation = new THREE.Euler();
        let objectStartScale = new THREE.Vector3();
        let initialMouseAngle = 0;
        let isOrbiting = false;
        let isPanning = false;
        let previousMousePosition = { x: 0, y: 0 };
        const orbitSpeed = 0.005;
        const panSpeed = 0.003;
        
        function getMousePosition(e) {
            const rect = threeCanvas.getBoundingClientRect();
            let clientX, clientY;
            
            if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }
            
            mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
        }
        
        function getGizmoObjects() {
            const gizmoObjects = [];
            if (gizmos.translate.visible) {
                gizmos.translate.children.forEach(child => {
                    if (child.isMesh) gizmoObjects.push(child);
                });
            }
            if (gizmos.rotate.visible) {
                gizmos.rotate.children.forEach(child => {
                    if (child.isMesh) gizmoObjects.push(child);
                });
            }
            if (gizmos.scale.visible) {
                gizmos.scale.children.forEach(child => {
                    if (child.isMesh) gizmoObjects.push(child);
                });
            }
            return gizmoObjects;
        }
        
        // Touch start
        threeCanvas.addEventListener('touchstart', (e) => {
            if (isDraggingPanel) return;
            
            touches = Array.from(e.touches);
            
            if (touches.length === 1) {
                getMousePosition(e);
                raycaster.setFromCamera(mouse, camera);
                
                const gizmoObjects = getGizmoObjects();
                const gizmoIntersects = raycaster.intersectObjects(gizmoObjects, false);
                
                if (gizmoIntersects.length > 0 && selectedObject) {
                    isDraggingGizmo = true;
                    const intersectedObj = gizmoIntersects[0].object;
                    activeAxis = intersectedObj.userData.axis;
                    activeGizmo = intersectedObj.userData.gizmoType;
                    
                    setupGizmoDragPlane();
                    
                    raycaster.ray.intersectPlane(dragPlane, dragStart);
                    objectStartPosition.copy(selectedObject.position);
                    objectStartRotation.copy(selectedObject.rotation);
                    objectStartScale.copy(selectedObject.scale);
                    
                    if (activeGizmo === 'rotate') {
                        const offset = dragStart.clone().sub(selectedObject.position);
                        initialMouseAngle = Math.atan2(offset.y, offset.x);
                    }
                } else {
                    isOrbiting = true;
                }
                
                previousMousePosition = { x: touches[0].clientX, y: touches[0].clientY };
                
            } else if (touches.length === 2) {
                lastPinchDistance = getTouchDistance(touches[0], touches[1]);
                lastTouchCenter = getTouchCenter(touches[0], touches[1]);
                isPinching = true;
            }
            
            e.preventDefault();
        }, { passive: false });
        
        function setupGizmoDragPlane() {
            const cameraDir = new THREE.Vector3();
            camera.getWorldDirection(cameraDir);
            
            if (activeGizmo === 'translate') {
                const axisVector = new THREE.Vector3();
                if (activeAxis === 'x') axisVector.set(1, 0, 0);
                else if (activeAxis === 'y') axisVector.set(0, 1, 0);
                else if (activeAxis === 'z') axisVector.set(0, 0, 1);
                
                // Create a plane perpendicular to camera that contains the axis
                let normal = new THREE.Vector3().crossVectors(cameraDir, axisVector);
                if (normal.length() < 0.01) {
                    // Camera aligned with axis, use a perpendicular vector
                    if (activeAxis === 'x') normal.set(0, 1, 0);
                    else if (activeAxis === 'y') normal.set(1, 0, 0);
                    else normal.set(0, 1, 0);
                }
                normal.normalize();
                
                // Now create perpendicular to this and the axis
                const planeNormal = new THREE.Vector3().crossVectors(axisVector, normal).normalize();
                dragPlane.setFromNormalAndCoplanarPoint(planeNormal, selectedObject.position);
            } else {
                // For rotate and scale, use camera-facing plane
                dragPlane.setFromNormalAndCoplanarPoint(cameraDir.negate(), selectedObject.position);
            }
        }
        
        // Touch move
        threeCanvas.addEventListener('touchmove', (e) => {
            if (isDraggingPanel) return;
            
            touches = Array.from(e.touches);
            
            if (touches.length === 1 && (isOrbiting || isDraggingGizmo)) {
                getMousePosition(e);
                
                if (isDraggingGizmo && selectedObject) {
                    raycaster.setFromCamera(mouse, camera);
                    
                    if (raycaster.ray.intersectPlane(dragPlane, dragCurrent)) {
                        performGizmoTransform();
                    }
                } else if (isOrbiting) {
                    const deltaX = touches[0].clientX - previousMousePosition.x;
                    const deltaY = touches[0].clientY - previousMousePosition.y;
                    
                    theta -= deltaX * orbitSpeed;
                    phi -= deltaY * orbitSpeed;
                    phi = Math.max(0.1, Math.min(Math.PI - 0.1, phi));
                    
                    updateCameraPosition();
                }
                
                previousMousePosition = { x: touches[0].clientX, y: touches[0].clientY };
                
            } else if (touches.length === 2 && isPinching) {
                const currentPinchDistance = getTouchDistance(touches[0], touches[1]);
                const currentTouchCenter = getTouchCenter(touches[0], touches[1]);
                
                // Pinch to zoom
                const pinchDelta = currentPinchDistance - lastPinchDistance;
                const zoomSpeed = 0.01;
                const newDistance = cameraDistance - pinchDelta * zoomSpeed;
                
                if (newDistance > 1 && newDistance < 100) {
                    cameraDistance = newDistance;
                }
                
                // Pan
                const deltaX = currentTouchCenter.x - lastTouchCenter.x;
                const deltaY = currentTouchCenter.y - lastTouchCenter.y;
                
                const distance = camera.position.distanceTo(lookAtTarget);
                const panScale = distance * panSpeed;
                
                const cameraRight = new THREE.Vector3();
                camera.getWorldDirection(cameraRight);
                cameraRight.cross(new THREE.Vector3(0, 1, 0)).normalize();
                
                const cameraUp = new THREE.Vector3();
                cameraUp.crossVectors(cameraRight, camera.getWorldDirection(new THREE.Vector3())).normalize();
                
                lookAtTarget.add(cameraRight.multiplyScalar(-deltaX * panScale));
                lookAtTarget.add(cameraUp.multiplyScalar(deltaY * panScale));
                
                lastPinchDistance = currentPinchDistance;
                lastTouchCenter = currentTouchCenter;
                
                updateCameraPosition();
            }
            
            e.preventDefault();
        }, { passive: false });
        
        function performGizmoTransform() {
            if (activeGizmo === 'translate') {
                const delta = dragCurrent.clone().sub(dragStart);
                
                if (activeAxis === 'x') {
                    selectedObject.position.x = objectStartPosition.x + delta.x;
                } else if (activeAxis === 'y') {
                    selectedObject.position.y = objectStartPosition.y + delta.y;
                } else if (activeAxis === 'z') {
                    selectedObject.position.z = objectStartPosition.z + delta.z;
                }
                
                updateGizmoVisibility();
                
            } else if (activeGizmo === 'rotate') {
                const offset = dragCurrent.clone().sub(selectedObject.position);
                const currentAngle = Math.atan2(offset.y, offset.x);
                const deltaAngle = currentAngle - initialMouseAngle;
                
                if (activeAxis === 'x') {
                    selectedObject.rotation.x = objectStartRotation.x + deltaAngle;
                } else if (activeAxis === 'y') {
                    selectedObject.rotation.y = objectStartRotation.y + deltaAngle;
                } else if (activeAxis === 'z') {
                    selectedObject.rotation.z = objectStartRotation.z + deltaAngle;
                }
                
            } else if (activeGizmo === 'scale') {
                const startDist = dragStart.distanceTo(selectedObject.position);
                const currentDist = dragCurrent.distanceTo(selectedObject.position);
                const scaleFactor = currentDist / (startDist || 1);
                
                if (activeAxis === 'x') {
                    selectedObject.scale.x = Math.max(0.1, objectStartScale.x * scaleFactor);
                } else if (activeAxis === 'y') {
                    selectedObject.scale.y = Math.max(0.1, objectStartScale.y * scaleFactor);
                } else if (activeAxis === 'z') {
                    selectedObject.scale.z = Math.max(0.1, objectStartScale.z * scaleFactor);
                }
                
                updateGizmoVisibility();
            }
            requestRenderIfNeeded();
        }
        
        // Mouse controls
        threeCanvas.addEventListener('mousedown', (e) => {
            if (isDraggingPanel) return;
            
            getMousePosition(e);
            
            if (e.button === 1) {
                isOrbiting = true;
                e.preventDefault();
                return;
            }
            
            if (e.button === 2) {
                isPanning = true;
                e.preventDefault();
                return;
            }
            
            if (e.button === 0) {
                raycaster.setFromCamera(mouse, camera);
                
                const gizmoObjects = getGizmoObjects();
                const gizmoIntersects = raycaster.intersectObjects(gizmoObjects, false);
                
                if (gizmoIntersects.length > 0 && selectedObject) {
                    isDraggingGizmo = true;
                    const intersectedObj = gizmoIntersects[0].object;
                    activeAxis = intersectedObj.userData.axis;
                    activeGizmo = intersectedObj.userData.gizmoType;
                    
                    setupGizmoDragPlane();
                    
                    raycaster.ray.intersectPlane(dragPlane, dragStart);
                    objectStartPosition.copy(selectedObject.position);
                    objectStartRotation.copy(selectedObject.rotation);
                    objectStartScale.copy(selectedObject.scale);
                    
                    if (activeGizmo === 'rotate') {
                        const offset = dragStart.clone().sub(selectedObject.position);
                        initialMouseAngle = Math.atan2(offset.y, offset.x);
                    }
                    
                    e.preventDefault();
                }
            }
            
            previousMousePosition = { x: e.clientX, y: e.clientY };
        });
        
        threeCanvas.addEventListener('mousemove', (e) => {
            if (isDraggingPanel) return;
            
            getMousePosition(e);
            
            if (isOrbiting) {
                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;
                
                theta -= deltaX * orbitSpeed;
                phi -= deltaY * orbitSpeed;
                phi = Math.max(0.1, Math.min(Math.PI - 0.1, phi));
                
                updateCameraPosition();
            } else if (isPanning) {
                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;
                
                const distance = camera.position.distanceTo(lookAtTarget);
                const panScale = distance * panSpeed;
                
                const cameraRight = new THREE.Vector3();
                camera.getWorldDirection(cameraRight);
                cameraRight.cross(new THREE.Vector3(0, 1, 0)).normalize();
                
                const cameraUp = new THREE.Vector3();
                cameraUp.crossVectors(cameraRight, camera.getWorldDirection(new THREE.Vector3())).normalize();
                
                lookAtTarget.add(cameraRight.multiplyScalar(-deltaX * panScale));
                lookAtTarget.add(cameraUp.multiplyScalar(deltaY * panScale));
                
                updateCameraPosition();
            } else if (isDraggingGizmo && selectedObject) {
                raycaster.setFromCamera(mouse, camera);
                
                if (raycaster.ray.intersectPlane(dragPlane, dragCurrent)) {
                    performGizmoTransform();
                }
            }
            
            previousMousePosition = { x: e.clientX, y: e.clientY };
        });
        
        threeCanvas.addEventListener('mouseup', () => {
            isDraggingGizmo = false;
            isOrbiting = false;
            isPanning = false;
            activeGizmo = null;
            activeAxis = null;
        });
        
        threeCanvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            
            const zoomSpeed = 0.5;
            const newDistance = cameraDistance + (e.deltaY > 0 ? zoomSpeed : -zoomSpeed);
            
            if (newDistance > 1 && newDistance < 100) {
                cameraDistance = newDistance;
                updateCameraPosition();
            }
        }, { passive: false });
        
        threeCanvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });
        
        // Touch end
        threeCanvas.addEventListener('touchend', (e) => {
            touches = Array.from(e.touches);
            
            if (touches.length === 0) {
                isDraggingGizmo = false;
                isOrbiting = false;
                isPanning = false;
                isPinching = false;
                activeGizmo = null;
                activeAxis = null;
            } else if (touches.length === 1) {
                isPanning = false;
                isPinching = false;
                lastPinchDistance = 0;
            }
        }, { passive: false });
        
        threeCanvas.addEventListener('touchcancel', (e) => {
            isDraggingGizmo = false;
            isOrbiting = false;
            isPanning = false;
            isPinching = false;
            activeGizmo = null;
            activeAxis = null;
        }, { passive: false });
        
        // Close modals on click outside
        window.addEventListener('click', (e) => {
            if (e.target === document.getElementById('renameModal')) {
                document.getElementById('renameModal').style.display = 'none';
            }
            if (e.target === document.getElementById('exportModal')) {
                document.getElementById('exportModal').style.display = 'none';
            }
        });
        
        updateObjectList();
        
        // OPTIMIZATION: Render on demand instead of continuous loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Only render when something has changed
            if (needsRender) {
                renderer.render(scene, camera);
                needsRender = false;
            }
        }
        animate();
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            requestRenderIfNeeded();
        });
    </script>
</body>
</html>
